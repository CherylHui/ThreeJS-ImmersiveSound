<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - GLTFloader</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="styles.css">
	</head>

	<body>
		<div id="info">
			<a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> - GLTFLoader<br />
			Battle Damaged Sci-fi Helmet by
			<a href="https://sketchfab.com/theblueturtle_" target="_blank" rel="noopener">theblueturtle_</a><br />
			<a href="https://hdrihaven.com/hdri/?h=royal_esplanade" target="_blank" rel="noopener">Royal Esplanade</a> by <a href="https://hdrihaven.com/" target="_blank" rel="noopener">HDRI Haven</a>
		</div>

		<!-- Import maps polyfill -->
		<!-- Remove this when import maps will be widely supported -->
		<!-- <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script> -->

		<script type="importmap">
			{
				"imports": {
					"three": "../three/build/three.module.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from  'three';
            

			import { OrbitControls } from '/three/examples/jsm/controls/OrbitControls.js';
			import { GLTFLoader } from '/three/examples/jsm/loaders/GLTFLoader.js';
			import { RGBELoader } from '/three/examples/jsm/loaders/RGBELoader.js';

			let camera, scene, renderer, clock;

let mesh;

let sign = 1;
const speed = 0.5;

init();
animate();


function init() {

	//const container = document.getElementById( 'container' );

	const container = document.createElement( 'div' );
	document.body.appendChild( container );

	camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.2, 100 );
	camera.position.set( 0, 5, 5 );

	scene = new THREE.Scene();

	clock = new THREE.Clock();

	const light1 = new THREE.PointLight( 0xff2200, 0.7 );
	light1.position.set( 100, 100, 100 );
	scene.add( light1 );

	const light2 = new THREE.PointLight( 0x22ff00, 0.7 );
	light2.position.set( - 100, - 100, - 100 );
	scene.add( light2 );

	scene.add( new THREE.AmbientLight( 0x111111 ) );

	const loader = new GLTFLoader();
	loader.load( '/assets/ball.gltf', function ( gltf ) {

		const geometry = new THREE.BoxGeometry( 1, 1, 1 );
		const material = new THREE.MeshBasicMaterial( { color: 0xffff00 } );
		mesh = new THREE.Mesh( geometry, material );
		scene.add( mesh );

		mesh.material.morphTargets = true;

		// mesh = gltf.scene.children;
		// console.log(mesh);
		// //mesh.rotation.z = Math.PI / 2;
		// //scene.add(mesh);

		// scene.add( gltf.scene );

	render();

		//

		const pointsMaterial = new THREE.PointsMaterial( {
			size: 10,
			sizeAttenuation: false,
			map: new THREE.TextureLoader().load( '/assets/screwTexture.jpg' ),
			alphaTest: 0.5
		} );

		const points = new THREE.Points( mesh.geometry, pointsMaterial );
		points.morphTargetInfluences = mesh.morphTargetInfluences;
		console.log(mesh.morphTargetInfluences);
		points.morphTargetDictionary = mesh.morphTargetDictionary;
		mesh.add( points );

	} );

	//

	renderer = new THREE.WebGLRenderer();
	renderer.setPixelRatio( window.devicePixelRatio );
	renderer.setSize( window.innerWidth, window.innerHeight );
	container.appendChild( renderer.domElement );

	//

	const controls = new OrbitControls( camera, renderer.domElement );
	controls.minDistance = 1;
	controls.maxDistance = 20;

	//

	window.addEventListener( 'resize', onWindowResize );
	document.addEventListener( 'visibilitychange', onVisibilityChange );

}

function onWindowResize() {

	camera.aspect = window.innerWidth / window.innerHeight;
	camera.updateProjectionMatrix();
	renderer.setSize( window.innerWidth, window.innerHeight );

}

function onVisibilityChange() {
	if ( document.hidden === true ) {
		clock.stop();
	} else {

		clock.start();
	}
}

function animate() {
	requestAnimationFrame( animate );
	render();
}

///////////music analysis///////////
var audio = new Audio("/media/audio.mp3"); //"/media/The-Stars.mp3"       
	audio.play();


	//audio anayser setup
	var context = new AudioContext();
	var src = context.createMediaElementSource(audio);
	var analyser = context.createAnalyser();
	src.connect(analyser);
	analyser.connect(context.destination);
	analyser.fftSize = 512;
	var bufferLength = analyser.frequencyBinCount;
	var dataArray = new Uint8Array(bufferLength);



//////render////////////////
function render() {
	const delta = clock.getDelta();
	console.log(mesh)

	if ( mesh !== undefined ) {

		const step = delta * speed;

		mesh.rotation.y += step;
		mesh.position.y += step;

		//mesh.morphTargetInfluences[ 1 ] = mesh.morphTargetInfluences[ 1 ] + step * sign;

		// if ( mesh.morphTargetInfluences[ 1 ] <= 0 || mesh.morphTargetInfluences[ 1 ] >= 1 ) {

		// 	sign *= - 1;

		// }
	}
	renderer.render( scene, camera );
}


function render2() {
	analyser.getByteFrequencyData(dataArray);
	console.log(dataArray)
	requestAnimationFrame(render2);

	var lowerHalfArray = dataArray.slice(0, (dataArray.length / 2) - 1);
	var upperHalfArray = dataArray.slice((dataArray.length / 2) - 1, dataArray.length - 1);

	var overallAvg = avg(dataArray);
	var lowerMax = max(lowerHalfArray);
	var lowerAvg = avg(lowerHalfArray);
	var upperMax = max(upperHalfArray);
	var upperAvg = avg(upperHalfArray);

	var lowerMaxFr = lowerMax / lowerHalfArray.length;
	var lowerAvgFr = lowerAvg / lowerHalfArray.length;
	var upperMaxFr = upperMax / upperHalfArray.length;
	var upperAvgFr = upperAvg / upperHalfArray.length;

	var bassFr = modulate(Math.pow(lowerMaxFr, 0.8), 0, 1, 0, 8);
	var treFr = modulate(upperAvgFr, 0, 1, 0, 4);

	const delta = clock.getDelta();

	if ( mesh !== undefined ) {
		const step = delta * speed;
		mesh.rotation.y += step;
		mesh.position.y = bassFr/8;
		mesh.position.x = treFr;
		mesh.scale.x = treFr;
		console.log(bassFr);
	}
	renderer.render( scene, camera );
};

render2();


		////////////////////////
        //helper functions
        function fractionate(val, minVal, maxVal) {
            return (val - minVal) / (maxVal - minVal);
        }

        function modulate(val, minVal, maxVal, outMin, outMax) {
            var fr = fractionate(val, minVal, maxVal);
            var delta = outMax - outMin;
            return outMin + (fr * delta);
        }

        function avg(arr) {
            var total = arr.reduce(function (sum, b) { return sum + b; });
            return (total / arr.length);
        }

        function max(arr) {
            return arr.reduce(function (a, b) { return Math.max(a, b); })
        }

		</script>

	</body>
</html>