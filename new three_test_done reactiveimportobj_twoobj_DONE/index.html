<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - GLTFloader</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="styles.css">
	</head>

	<body>
		<div id="info">
			<a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> - GLTFLoader<br />
			Battle Damaged Sci-fi Helmet by
			<a href="https://sketchfab.com/theblueturtle_" target="_blank" rel="noopener">theblueturtle_</a><br />
			<a href="https://hdrihaven.com/hdri/?h=royal_esplanade" target="_blank" rel="noopener">Royal Esplanade</a> by <a href="https://hdrihaven.com/" target="_blank" rel="noopener">HDRI Haven</a>
		</div>

		<!-- Import maps polyfill -->
		<!-- Remove this when import maps will be widely supported -->
		<!-- <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script> -->

		<script type="importmap">
			{
				"imports": {
					"three": "../three/build/three.module.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from  'three';
            

			import { OrbitControls } from '/three/examples/jsm/controls/OrbitControls.js';
			import { GLTFLoader } from '/three/examples/jsm/loaders/GLTFLoader.js';
			import { RGBELoader } from '/three/examples/jsm/loaders/RGBELoader.js';

let camera, scene, renderer, clock;

var mesh;
var mesh2;


let sign = 1;
const speed = 0.5;

init();
animate();


function init() {

	//const container = document.getElementById( 'container' );

	const container = document.createElement( 'div' );
	document.body.appendChild( container );

	camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.2, 100 );
	camera.position.set( 0, 5, 5 );

	scene = new THREE.Scene();

	clock = new THREE.Clock();

	const light1 = new THREE.PointLight( 0xff2200, 0.7 );
	light1.position.set( 100, 100, 100 );
	scene.add( light1 );

	const light2 = new THREE.PointLight( 0x22ff00, 0.7 );
	light2.position.set( - 100, - 100, - 100 );
	scene.add( light2 );

	scene.add( new THREE.AmbientLight( 0x111111 ) );

	
	const loader = new GLTFLoader();
	loader.load( '/assets/heart.gltf', function ( gltf ) {
		gltf.scene.traverse( function ( node ) {
						if ( node.isMesh ) mesh = node;
					} );
					mesh.material.morphTargets = true;
					mesh.rotation.z = Math.PI / 2;
					//mesh.material.visible = true;
					
					scene.add( mesh );
					
		//
		var pointsMaterial = new THREE.PointsMaterial( {
			size: 10,
			sizeAttenuation: false,
			map: new THREE.TextureLoader().load( 'assets/disc.png' ),
			alphaTest: 0.5,
			//morphTargets: true
		} );

		var points = new THREE.Points( mesh.geometry, pointsMaterial );
		


		console.log(pointsMaterial);

		points.morphTargetInfluences = mesh.morphTargetInfluences;
		console.log(mesh.morphTargetInfluences)
		points.morphTargetDictionary = mesh.morphTargetDictionary;

		mesh.add( points );

	} );




	//////////second model///////////////
	loader.load( '/assets/AnimatedMorphSphereold.gltf', function ( gltf ) {
		gltf.scene.traverse( function ( node ) {
						if ( node.isMesh ) mesh2 = node;
					} );
					mesh2.material.morphTargets = true;
					mesh2.rotation.y = Math.PI / 2;
					//mesh.material.visible = true;
					
					scene.add( mesh2 );
					
		//
		var pointsMaterial = new THREE.PointsMaterial( {
			size: 10,
			sizeAttenuation: false,
			map: new THREE.TextureLoader().load( 'assets/disc.png' ),
			alphaTest: 0.5,
			//morphTargets: true
		} );

		var points = new THREE.Points( mesh2.geometry, pointsMaterial );

		points.morphTargetInfluences = mesh2.morphTargetInfluences;
		points.morphTargetDictionary = mesh2.morphTargetDictionary;

		mesh2.add( points );

	} );


	//

	renderer = new THREE.WebGLRenderer();
	renderer.setPixelRatio( window.devicePixelRatio );
	renderer.setSize( window.innerWidth, window.innerHeight );
	container.appendChild( renderer.domElement );

	//

	const controls = new OrbitControls( camera, renderer.domElement );
	controls.minDistance = 1;
	controls.maxDistance = 20;

	//

	window.addEventListener( 'resize', onWindowResize );
	document.addEventListener( 'visibilitychange', onVisibilityChange );

}

function onWindowResize() {

	camera.aspect = window.innerWidth / window.innerHeight;
	camera.updateProjectionMatrix();
	renderer.setSize( window.innerWidth, window.innerHeight );

}

function onVisibilityChange() {
	if ( document.hidden === true ) {
		clock.stop();
	} else {

		clock.start();
	}
}

function animate() {
	requestAnimationFrame( animate );
	render();
}

///////////music analysis///////////
var audio = new Audio("/media/HoneyMoon.mp3");   
	audio.play();


	//audio anayser setup
	var context = new AudioContext();
	var src = context.createMediaElementSource(audio);
	var analyser = context.createAnalyser();
	src.connect(analyser);
	analyser.connect(context.destination);
	analyser.fftSize = 512;
	var bufferLength = analyser.frequencyBinCount;
	var dataArray = new Uint8Array(bufferLength);



//////render////////////////
function render() {
	//const delta = clock.getDelta();
	//console.log(mesh)

	// if ( mesh !== undefined ) {

	// 	const step = delta * speed;

	// 	mesh.rotation.y += step;
	// 	mesh.position.y += step;

	// 	mesh.morphTargetInfluences[ 1 ] = mesh.morphTargetInfluences[ 1 ] + step * sign;

	// 	if ( mesh.morphTargetInfluences[ 1 ] <= 0 || mesh.morphTargetInfluences[ 1 ] >= 1 ) {

	// 		sign *= - 1;

	// 	}
	// }
	renderer.render( scene, camera );
}


function render2() {
	analyser.getByteFrequencyData(dataArray);
	//console.log(dataArray)
	requestAnimationFrame(render2);

	var lowerHalfArray = dataArray.slice(0, (dataArray.length / 2) - 1);
	var upperHalfArray = dataArray.slice((dataArray.length / 2) - 1, dataArray.length - 1);

	var overallAvg = avg(dataArray);
	var lowerMax = max(lowerHalfArray);
	var lowerAvg = avg(lowerHalfArray);
	var upperMax = max(upperHalfArray);
	var upperAvg = avg(upperHalfArray);

	var lowerMaxFr = lowerMax / lowerHalfArray.length;
	var lowerAvgFr = lowerAvg / lowerHalfArray.length;
	var upperMaxFr = upperMax / upperHalfArray.length;
	var upperAvgFr = upperAvg / upperHalfArray.length;

	var bassFr = modulate(Math.pow(lowerMaxFr, 0.8), 0, 1, 0, 8);
	var lowFr = modulate(Math.pow(lowerAvgFr, 0.8), 0, 1, 0, 8);
	var treFr = modulate(upperMaxFr, 0, 1, 0, 4);

	

	const delta = clock.getDelta();

	if ( mesh !== undefined ) {
		// const step = delta * speed;
		// mesh.rotation.y += step;
		//mesh.position.y = bassFr/8;
		// mesh.position.x = treFr;
		mesh.scale.x = 50*treFr/2;
		mesh.scale.y = 50*treFr/2;
		mesh.scale.z = 50*treFr/2;
		// console.log(bassFr);


		var step = delta * speed;

					mesh.rotation.y += step;

					mesh.morphTargetInfluences[ 1 ] = mesh.morphTargetInfluences[ 1 ] + step * sign;

					if ( mesh.morphTargetInfluences[ 1 ] <= 0 || mesh.morphTargetInfluences[ 1 ] >= 1 ) {

						sign *= - 1;
					}

		
	}



	/////////////SECOND MODEL/////////////
	if ( mesh2 !== undefined ) {
		// const step = delta * speed;
		// mesh2.rotation.y += step;
		mesh2.position.x = 0.5;
		// mesh2.position.x = treFr;
		mesh2.scale.x = 10*lowFr;
		mesh2.scale.y = 10*lowFr;
		mesh2.scale.z = 10*lowFr;
		// console.log(bassFr);


		var step = delta * speed;

					mesh2.rotation.y += step;

					mesh2.morphTargetInfluences[ 1 ] = mesh2.morphTargetInfluences[ 1 ] + step * sign;

					if ( mesh2.morphTargetInfluences[ 1 ] <= 0 || mesh2.morphTargetInfluences[ 1 ] >= 1 ) {

						sign *= - 1;
					}

		
	}
	renderer.render( scene, camera );
};

render2();


		////////////////////////
        //helper functions
        function fractionate(val, minVal, maxVal) {
            return (val - minVal) / (maxVal - minVal);
        }

        function modulate(val, minVal, maxVal, outMin, outMax) {
            var fr = fractionate(val, minVal, maxVal);
            var delta = outMax - outMin;
            return outMin + (fr * delta);
        }

        function avg(arr) {
            var total = arr.reduce(function (sum, b) { return sum + b; });
            return (total / arr.length);
        }

        function max(arr) {
            return arr.reduce(function (a, b) { return Math.max(a, b); })
        }

		</script>

	</body>
</html>